# Fixed-Point Alignment Plan (Encoder Energy Quantization Pipeline)

## Goal
Bring the Rust `fixed_point` path into behavioral alignment with the C fixed-point implementation by removing the float→fixed “mixed” pipeline and ensuring all energy quantization inputs are produced in true fixed-point.

## Scope
Primary focus: CELT encoder energy quantization pipeline and its dependencies.
Target files (expected):
- `src/celt/celt_encoder.rs`
- `src/celt/types.rs`
- `src/celt/mdct_fixed.rs`
- `src/celt/fixed_arch.rs` / `src/celt/fixed_ops.rs`
- Tests under `src/celt/*` and `ctests/`

## Step-by-Step Plan

### 1) Inventory & invariants — Done
- Locate all fixed-point call sites in encoder energy path:
  - `amp2_log2_fixed`
  - `quant_coarse_energy_fixed`
  - `quant_fine_energy_fixed`
  - `quant_energy_finalise_fixed`
- Confirm required invariants in C:
  - `bandE` must be strictly positive
  - fixed `celt_sig` scaling / `SIG_SHIFT` / `DB_SHIFT` usage

### 2) Add fixed MDCT to encoder state (mirror decoder) — Done
- Add to encoder allocation/state:
  - `fixed_mdct: FixedMdctLookup`
  - `fixed_window: Vec<FixedCeltCoef>`
- Initialize from mode in encoder alloc/constructor:
  - `FixedMdctLookup::new(mode.mdct.len(), mode.mdct.max_shift())`
  - `fixed_window` derived from `mode.window` (float→fixed conversion)
- Ensure size accounting if needed.

### 3) Implement `compute_mdcts_fixed` for encoder — Done
- New fixed MDCT path using `mdct_fixed::clt_mdct_forward_fixed`.
- Input should be fixed-point time samples (`FixedCeltSig`).
- Output is fixed-point frequency spectrum (`FixedCeltSig`).
- Match C fixed-point scaling and window application.

### 4) Provide fixed-point input buffers — Done
- Decide on source of fixed input:
  - For fixed-point build, generate fixed PCM from input and keep fixed time buffer.
  - Ensure preemphasis path has a fixed-point variant or implement conversion just before MDCT.
- Avoid float→fixed in the energy path; only allow conversion for diagnostics.

### 5) Switch energy quantization pipeline to fixed-only data — Done
- In `celt_encode_with_ec_inner`, under `fixed_point`:
  - Use fixed MDCT output to compute `band_e_fixed`.
  - Feed `band_e_fixed` into `amp2_log2_fixed`.
  - Do not derive `band_e_fixed` from float MDCT output.
- Keep float `band_log_e` in sync only for non-fixed downstream users.

### 6) Remove temporary clamp once invariant is satisfied — Done
- Remove any “bandE <= 0 → EPSILON” clamp added for stability.
- Confirm `band_e_fixed > 0` holds end-to-end without guard.

### 7) Tests — Done
- Add/adjust Rust tests to validate:
  - fixed pipeline doesn’t panic on existing encode smoke tests
  - fixed log-energy outputs and quantization match C for fixed-point
- Ensure ctests already exist for the fixed-point functions; mirror in Rust.

### 8) Verification — Done
Run required commands:
- `cargo check --all-features`
- `TEST_OPUS_NOFUZZ=1 cargo test --all-features --release`
- `cargo test --all-features --lib`
- `cargo clippy --all-features`

## Exit Criteria
- No float→fixed conversions are used as inputs to fixed energy quantization (except for optional debug sync).
- `amp2_log2_fixed` never receives non-positive energy values.
- Rust fixed-point output matches C fixed-point behavior for the tested energy pipeline.
- All required commands pass.

## Current float-math call sites (ast-grep scan, 2026-01-28)
The list below was generated by scanning `src/celt` for calls to float math
helpers (`celt_sqrt`, `celt_rsqrt`, `celt_rsqrt_norm`, `celt_rcp`,
`celt_div`, `celt_cos_norm`, `celt_exp2`, `celt_log2`), excluding
`math.rs`/`math_fixed.rs`. This is a raw inventory; each site still needs
manual review to confirm whether it is already gated by
`#[cfg(not(feature = "fixed_point"))]` or a test-only path.

- `src/celt/bands.rs:419:23` — `celt_sqrt($A)`
- `src/celt/bands.rs:420:24` — `celt_sqrt($A)`
- `src/celt/bands.rs:1351:25` — `celt_sqrt($A)`
- `src/celt/bands.rs:3199:26` — `celt_sqrt($A)`
- `src/celt/bands.rs:3368:28` — `celt_exp2($A)`
- `src/celt/bands.rs:3369:22` — `celt_rsqrt($A)`
- `src/celt/bands.rs:3399:31` — `celt_exp2($A)`
- `src/celt/bands.rs:3457:17` — `celt_rsqrt_norm($A)`
- `src/celt/bands.rs:3458:17` — `celt_rsqrt_norm($A)`
- `src/celt/bands.rs:3835:42` — `celt_sqrt($A)`
- `src/celt/bands.rs:3934:24` — `celt_sqrt($A)`
- `src/celt/bands.rs:4299:20` — `celt_exp2($A)`
- `src/celt/bands.rs:4712:21` — `celt_rsqrt_norm($A)`
- `src/celt/bands.rs:4713:21` — `celt_rsqrt_norm($A)`
- `src/celt/bands.rs:5320:24` — `celt_exp2($A)`
- `src/celt/bands.rs:5348:20` — `celt_exp2($A)`
- `src/celt/celt_decoder.rs:797:25` — `celt_sqrt($A)`
- `src/celt/celt_decoder.rs:841:33` — `celt_sqrt($A)`
- `src/celt/celt_encoder.rs:1840:22` — `celt_log2($A)`
- `src/celt/celt_encoder.rs:1841:19` — `celt_log2($A)`
- `src/celt/celt_encoder.rs:2617:28` — `celt_sqrt($A)`
- `src/celt/celt_encoder.rs:2694:22` — `celt_sqrt($A)`
- `src/celt/celt_encoder.rs:2702:20` — `celt_sqrt($A)`
- `src/celt/celt_encoder.rs:3040:33` — `celt_exp2($A)`
- `src/celt/celt_encoder.rs:4709:27` — `celt_sqrt($A)`
- `src/celt/celt_encoder.rs:5562:13` — `celt_rcp($A)`
- `src/celt/celt_encoder.rs:7222:22` — `celt_log2($A)`
- `src/celt/celt_encoder.rs:7223:19` — `celt_log2($A)`
- `src/celt/kiss_fft_fixed.rs:289:17` — `celt_cos_norm($A)`
- `src/celt/kiss_fft_fixed.rs:290:17` — `celt_cos_norm($A)`
- `src/celt/mdct_fixed.rs:66:30` — `celt_cos_norm($A)`
- `src/celt/pitch.rs:346:11` — `celt_sqrt($A)`
- `src/celt/pitch.rs:506:15` — `celt_rsqrt_norm($A)`
- `src/celt/pitch.rs:1522:30` — `celt_sqrt($A)`
- `src/celt/quant_bands.rs:1018:25` — `celt_log2($A)`
- `src/celt/quant_bands.rs:1112:27` — `celt_exp2($A)`
- `src/celt/vq.rs:101:16` — `celt_div($A, $B)`
- `src/celt/vq.rs:106:13` — `celt_cos_norm($A)`
- `src/celt/vq.rs:107:13` — `celt_cos_norm($A)`
- `src/celt/vq.rs:166:17` — `celt_rsqrt_norm($A)`
- `src/celt/vq.rs:251:44` — `celt_rcp($A)`
- `src/celt/vq.rs:374:17` — `celt_rsqrt_norm($A)`
- `src/celt/vq.rs:418:15` — `celt_sqrt($A)`
- `src/celt/vq.rs:419:16` — `celt_sqrt($A)`
