#![allow(dead_code)]

//! Helpers ported from `celt/modes.c`.
//!
//! The reference implementation builds the band layout dynamically depending on
//! the sampling rate and frame size.  The helpers in this module translate the
//! Bark-scale based construction so that future porting work can reuse the
//! generated tables without reaching back into the C code.

use alloc::vec;
use alloc::vec::Vec;
use core::convert::TryFrom;

use crate::celt::types::OpusInt32;

/// Precomputed 5 ms critical band edges used by CELT's reference configuration.
const EBAND_5MS: [i16; 22] = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 34, 40, 48, 60, 78, 100,
];

/// Bark-scale breakpoints used when constructing the band layout for custom modes.
const BARK_FREQ: [i32; BARK_BANDS + 1] = [
    0, 100, 200, 300, 400, 510, 630, 770, 920, 1080, 1270, 1480, 1720, 2000, 2320, 2700, 3150,
    3700, 4400, 5300, 6400, 7700, 9500, 12000, 15500, 20000,
];

/// Number of Bark bands covered by the table in the reference implementation.
const BARK_BANDS: usize = 25;

/// Result of [`compute_ebands`], mirroring the layout generated by the C helper.
#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) struct EBandLayout {
    /// Band edges measured in frequency bins.
    pub bands: Vec<i16>,
    /// Number of bands represented by [`bands`].
    pub num_bands: usize,
}

impl EBandLayout {
    fn new(bands: Vec<i16>, num_bands: usize) -> Self {
        debug_assert_eq!(bands.len(), num_bands + 1);
        Self { bands, num_bands }
    }
}

/// Computes the Bark-derived energy band edges for a given configuration.
///
/// Ports `compute_ebands()` from `celt/modes.c`, adapting the allocation logic
/// to return an owned vector.  The helper reproduces the integer arithmetic of
/// the reference implementation so that the resulting band boundaries match bit
/// for bit.
#[must_use]
#[allow(clippy::too_many_lines)]
pub(crate) fn compute_ebands(
    sample_rate: OpusInt32,
    frame_size: usize,
    resolution: OpusInt32,
) -> EBandLayout {
    assert!(resolution > 0, "resolution must be strictly positive");
    assert!(frame_size > 0, "frame size must be non-zero");
    let frame_size_i32 = OpusInt32::try_from(frame_size).expect("frame size fits in 32 bits");

    if i64::from(sample_rate) == 400 * i64::from(frame_size_i32) {
        let bands = EBAND_5MS.to_vec();
        let num_bands = bands.len() - 1;
        return EBandLayout::new(bands, num_bands);
    }

    let mut n_bark = 1usize;
    while n_bark < BARK_BANDS {
        if i64::from(BARK_FREQ[n_bark + 1]) * 2 >= i64::from(sample_rate) {
            break;
        }
        n_bark += 1;
    }

    let mut lin = 0usize;
    while lin < n_bark {
        if BARK_FREQ[lin + 1] - BARK_FREQ[lin] >= resolution {
            break;
        }
        lin += 1;
    }

    let low = ((BARK_FREQ[lin] + resolution / 2) / resolution) as usize;
    let high = n_bark - lin;
    let mut num_bands = low + high;
    let mut bands = vec![0i32; num_bands + 2];

    for i in 0..low {
        bands[i] = i as i32;
    }

    let mut offset = 0i32;
    if low > 0 {
        let previous = bands[low - 1];
        offset = previous * resolution - BARK_FREQ[lin.saturating_sub(1)];
    }

    for i in 0..high {
        let target = BARK_FREQ[lin + i];
        let value = ((target + offset / 2 + resolution) / (2 * resolution)) * 2;
        bands[i + low] = value;
        offset = value * resolution - target;
    }

    for i in 0..num_bands {
        let threshold = i as i32;
        if bands[i] < threshold {
            bands[i] = threshold;
        }
    }

    let mut end_band = ((BARK_FREQ[n_bark] + resolution) / (2 * resolution)) * 2;
    if end_band > frame_size_i32 {
        end_band = frame_size_i32;
    }
    bands[num_bands] = end_band;

    if num_bands > 1 {
        for i in 1..(num_bands - 1) {
            let prev = bands[i - 1];
            let curr = bands[i];
            let next = bands[i + 1];
            if next - curr < curr - prev {
                bands[i] -= (2 * curr - prev - next) / 2;
            }
        }
    }

    let mut j = 0usize;
    for i in 0..num_bands {
        if bands[i + 1] > bands[j] {
            j += 1;
            bands[j] = bands[i + 1];
        }
    }
    num_bands = j;
    bands.truncate(num_bands + 1);

    if num_bands >= 1 {
        let last_width = bands[num_bands] - bands[num_bands - 1];
        for i in 1..num_bands {
            let width = bands[i] - bands[i - 1];
            debug_assert!(width <= last_width);
            debug_assert!(bands[i + 1] - bands[i] <= 2 * width);
        }
    }

    let final_bands: Vec<i16> = bands
        .into_iter()
        .map(|value| i16::try_from(value).expect("band index fits in 16 bits"))
        .collect();

    EBandLayout::new(final_bands, num_bands)
}

#[cfg(test)]
mod tests {
    use alloc::vec;
    use alloc::vec::Vec;

    use super::{EBAND_5MS, compute_ebands};

    #[test]
    fn returns_standard_layout_for_5ms_frames() {
        let layout = compute_ebands(48_000, 120, 200);
        assert_eq!(layout.num_bands, EBAND_5MS.len() - 1);
        assert_eq!(layout.bands, EBAND_5MS.to_vec());
    }

    #[test]
    fn computes_layout_for_48k_10ms_frame() {
        let frame_size = 480usize;
        let resolution = ((48_000 + frame_size as i32) / (2 * frame_size as i32)) as i32;
        let layout = compute_ebands(48_000, frame_size, resolution);
        let expected: Vec<i16> = vec![
            0, 2, 4, 6, 8, 10, 12, 15, 18, 22, 26, 30, 34, 40, 46, 54, 64, 74, 88, 106, 128, 154,
            190, 240, 310, 400,
        ];
        assert_eq!(layout.num_bands, expected.len() - 1);
        assert_eq!(layout.bands, expected);
    }

    #[test]
    fn computes_layout_for_16k_frame() {
        let frame_size = 320usize;
        let resolution = ((16_000 + frame_size as i32) / (2 * frame_size as i32)) as i32;
        let layout = compute_ebands(16_000, frame_size, resolution);
        let expected: Vec<i16> = vec![
            0, 4, 8, 12, 16, 20, 26, 32, 38, 44, 52, 60, 70, 80, 92, 108, 126, 148, 176, 212, 256,
            308,
        ];
        assert_eq!(layout.num_bands, expected.len() - 1);
        assert_eq!(layout.bands, expected);
    }
}
