#![allow(dead_code)]

//! Helpers ported from `celt/modes.c`.
//!
//! The reference implementation builds the band layout dynamically depending on
//! the sampling rate and frame size.  The helpers in this module translate the
//! Bark-scale based construction so that future porting work can reuse the
//! generated tables without reaching back into the C code.

use alloc::vec;
use alloc::vec::Vec;
use core::convert::TryFrom;

use crate::celt::types::{CeltCoef, OpusInt16, OpusInt32, OpusVal16};
use libm::sinf;

/// Precomputed 5 ms critical band edges used by CELT's reference configuration.
const EBAND_5MS: [i16; 22] = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 34, 40, 48, 60, 78, 100,
];

/// Number of bands represented by [`EBAND_5MS`].
const MAX_BANDS: usize = EBAND_5MS.len() - 1;

/// Number of allocation vectors precomputed by the reference implementation.
pub(crate) const BITALLOC_SIZE: usize = 11;

/// Bit allocation matrix copied from `celt/modes.c`.
const BAND_ALLOCATION: [u8; BITALLOC_SIZE * MAX_BANDS] = [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90, 80, 75, 69, 63, 56, 49, 40,
    34, 29, 20, 18, 10, 0, 0, 0, 0, 0, 0, 0, 0, 110, 100, 90, 84, 78, 71, 65, 58, 51, 45, 39, 32,
    26, 20, 12, 0, 0, 0, 0, 0, 0, 118, 110, 103, 93, 86, 80, 75, 70, 65, 59, 53, 47, 40, 31, 23,
    15, 4, 0, 0, 0, 0, 126, 119, 112, 104, 95, 89, 83, 78, 72, 66, 60, 54, 47, 39, 32, 25, 17, 12,
    1, 0, 0, 134, 127, 120, 114, 103, 97, 91, 85, 78, 72, 66, 60, 54, 47, 41, 35, 29, 23, 16, 10,
    1, 144, 137, 130, 124, 113, 107, 101, 95, 88, 82, 76, 70, 64, 57, 51, 45, 39, 33, 26, 15, 1,
    152, 145, 138, 132, 123, 117, 111, 105, 98, 92, 86, 80, 74, 67, 61, 55, 49, 43, 36, 20, 1, 162,
    155, 148, 142, 133, 127, 121, 115, 108, 102, 96, 90, 84, 77, 71, 65, 59, 53, 46, 30, 1, 172,
    165, 158, 152, 143, 137, 131, 125, 118, 112, 106, 100, 94, 87, 81, 75, 69, 63, 56, 45, 20, 200,
    200, 200, 200, 200, 200, 200, 200, 198, 193, 188, 183, 178, 173, 168, 163, 158, 153, 148, 129,
    104,
];

/// Bark-scale breakpoints used when constructing the band layout for custom modes.
const BARK_FREQ: [i32; BARK_BANDS + 1] = [
    0, 100, 200, 300, 400, 510, 630, 770, 920, 1080, 1270, 1480, 1720, 2000, 2320, 2700, 3150,
    3700, 4400, 5300, 6400, 7700, 9500, 12000, 15500, 20000,
];

/// Number of Bark bands covered by the table in the reference implementation.
const BARK_BANDS: usize = 25;

/// Result of [`compute_ebands`], mirroring the layout generated by the C helper.
#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) struct EBandLayout {
    /// Band edges measured in frequency bins.
    pub bands: Vec<i16>,
    /// Number of bands represented by [`bands`].
    pub num_bands: usize,
}

impl EBandLayout {
    fn new(bands: Vec<i16>, num_bands: usize) -> Self {
        debug_assert_eq!(bands.len(), num_bands + 1);
        Self { bands, num_bands }
    }
}

/// Interpolated allocation vectors describing how many bits each band should receive.
#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) struct AllocationTable {
    vectors: Vec<u8>,
    num_bands: usize,
}

impl AllocationTable {
    fn new(vectors: Vec<u8>, num_bands: usize) -> Self {
        debug_assert_eq!(vectors.len(), num_bands * BITALLOC_SIZE);
        Self { vectors, num_bands }
    }

    /// Returns the flattened allocation vectors with `num_bands` elements per row.
    #[must_use]
    pub fn vectors(&self) -> &[u8] {
        &self.vectors
    }

    /// Number of allocation bands represented by the table.
    #[must_use]
    pub fn num_bands(&self) -> usize {
        self.num_bands
    }

    /// Number of allocation vectors stored in the table.
    #[must_use]
    pub fn num_vectors(&self) -> usize {
        BITALLOC_SIZE
    }
}

/// Computes the Bark-derived energy band edges for a given configuration.
///
/// Ports `compute_ebands()` from `celt/modes.c`, adapting the allocation logic
/// to return an owned vector.  The helper reproduces the integer arithmetic of
/// the reference implementation so that the resulting band boundaries match bit
/// for bit.
#[must_use]
#[allow(clippy::too_many_lines)]
pub(crate) fn compute_ebands(
    sample_rate: OpusInt32,
    frame_size: usize,
    resolution: OpusInt32,
) -> EBandLayout {
    assert!(resolution > 0, "resolution must be strictly positive");
    assert!(frame_size > 0, "frame size must be non-zero");
    let frame_size_i32 = OpusInt32::try_from(frame_size).expect("frame size fits in 32 bits");

    if i64::from(sample_rate) == 400 * i64::from(frame_size_i32) {
        let bands = EBAND_5MS.to_vec();
        let num_bands = bands.len() - 1;
        return EBandLayout::new(bands, num_bands);
    }

    let mut n_bark = 1usize;
    while n_bark < BARK_BANDS {
        if i64::from(BARK_FREQ[n_bark + 1]) * 2 >= i64::from(sample_rate) {
            break;
        }
        n_bark += 1;
    }

    let mut lin = 0usize;
    while lin < n_bark {
        if BARK_FREQ[lin + 1] - BARK_FREQ[lin] >= resolution {
            break;
        }
        lin += 1;
    }

    let low = ((BARK_FREQ[lin] + resolution / 2) / resolution) as usize;
    let high = n_bark - lin;
    let mut num_bands = low + high;
    let mut bands = vec![0i32; num_bands + 2];

    for i in 0..low {
        bands[i] = i as i32;
    }

    let mut offset = 0i32;
    if low > 0 {
        let previous = bands[low - 1];
        offset = previous * resolution - BARK_FREQ[lin.saturating_sub(1)];
    }

    for i in 0..high {
        let target = BARK_FREQ[lin + i];
        let value = ((target + offset / 2 + resolution) / (2 * resolution)) * 2;
        bands[i + low] = value;
        offset = value * resolution - target;
    }

    for i in 0..num_bands {
        let threshold = i as i32;
        if bands[i] < threshold {
            bands[i] = threshold;
        }
    }

    let mut end_band = ((BARK_FREQ[n_bark] + resolution) / (2 * resolution)) * 2;
    if end_band > frame_size_i32 {
        end_band = frame_size_i32;
    }
    bands[num_bands] = end_band;

    if num_bands > 1 {
        for i in 1..(num_bands - 1) {
            let prev = bands[i - 1];
            let curr = bands[i];
            let next = bands[i + 1];
            if next - curr < curr - prev {
                bands[i] -= (2 * curr - prev - next) / 2;
            }
        }
    }

    let mut j = 0usize;
    for i in 0..num_bands {
        if bands[i + 1] > bands[j] {
            j += 1;
            bands[j] = bands[i + 1];
        }
    }
    num_bands = j;
    bands.truncate(num_bands + 1);

    if num_bands >= 1 {
        let last_width = bands[num_bands] - bands[num_bands - 1];
        for i in 1..num_bands {
            let width = bands[i] - bands[i - 1];
            debug_assert!(width <= last_width);
            debug_assert!(bands[i + 1] - bands[i] <= 2 * width);
        }
    }

    let final_bands: Vec<i16> = bands
        .into_iter()
        .map(|value| i16::try_from(value).expect("band index fits in 16 bits"))
        .collect();

    EBandLayout::new(final_bands, num_bands)
}

/// Computes the bit allocation vectors for a given band layout.
///
/// Ports `compute_allocation_table()` from `celt/modes.c`. The helper interpolates the
/// 5 ms reference bit-allocation curves so that custom band layouts receive a consistent
/// distribution of coarse energy bits.
#[must_use]
pub(crate) fn compute_allocation_table(
    sample_rate: OpusInt32,
    short_mdct_size: usize,
    layout: &EBandLayout,
) -> AllocationTable {
    assert!(short_mdct_size > 0, "short MDCT size must be non-zero");
    let nb_bands = layout.num_bands;
    assert!(layout.bands.len() >= nb_bands + 1);

    let mut vectors = vec![0u8; BITALLOC_SIZE * nb_bands];
    let mdct_size_i64 = i64::try_from(short_mdct_size).expect("short MDCT size fits in 64 bits");
    if i64::from(sample_rate) == 400 * mdct_size_i64 {
        let count = BITALLOC_SIZE * nb_bands;
        vectors.copy_from_slice(&BAND_ALLOCATION[..count]);
        return AllocationTable::new(vectors, nb_bands);
    }

    let sample_rate_i64 = i64::from(sample_rate);

    for vec_idx in 0..BITALLOC_SIZE {
        for band in 0..nb_bands {
            let mut k = 0usize;
            let target = i64::from(layout.bands[band]) * sample_rate_i64 / mdct_size_i64;
            while k < MAX_BANDS {
                let threshold = 400 * i64::from(EBAND_5MS[k]);
                if threshold > target {
                    break;
                }
                k += 1;
            }

            let value = if k >= MAX_BANDS {
                BAND_ALLOCATION[vec_idx * MAX_BANDS + (MAX_BANDS - 1)]
            } else {
                let upper = k.max(1);
                let prev_freq = 400 * i64::from(EBAND_5MS[upper - 1]);
                let next_freq = 400 * i64::from(EBAND_5MS[upper]);
                let a1 = target - prev_freq;
                let a0 = next_freq - target;
                let numerator = a0 * i64::from(BAND_ALLOCATION[vec_idx * MAX_BANDS + (upper - 1)])
                    + a1 * i64::from(BAND_ALLOCATION[vec_idx * MAX_BANDS + upper]);
                (numerator / (a0 + a1)) as u8
            };

            vectors[vec_idx * nb_bands + band] = value;
        }
    }

    AllocationTable::new(vectors, nb_bands)
}

/// Returns the pre-emphasis filter coefficients for a given sampling rate.
///
/// Ports the float configuration of the `opus_custom_mode_create()` logic from
/// `celt/modes.c`. The reference implementation selects one of four
/// hard-coded responses depending on the sampling rate, approximating the
/// behaviour of the canonical 48 kHz filter at lower rates. The returned taps
/// are ordered to match the `mode->preemph` initialisation in the C source.
#[must_use]
pub(crate) fn compute_preemphasis(sample_rate: OpusInt32) -> [OpusVal16; 4] {
    if sample_rate < 12_000 {
        [0.350_006_1, -0.179_992_68, 0.271_996_8, 3.676_513_7]
    } else if sample_rate < 24_000 {
        [0.600_006_1, -0.179_992_68, 0.442_499_88, 2.259_887_7]
    } else if sample_rate < 40_000 {
        [0.779_998_8, -0.100_006_1, 0.749_977_1, 1.333_374]
    } else {
        [0.850_006_1, 0.0, 1.0, 1.0]
    }
}

/// Generates the sine-window used by CELT's MDCT overlap.
///
/// Ports the float configuration of the window initialisation performed inside
/// `opus_custom_mode_create()` in `celt/modes.c`.  The helper reproduces the
/// nested sine computation so that the resulting coefficients match the
/// bit-exact tables expected by the transform.
#[must_use]
pub(crate) fn compute_mdct_window(overlap: usize) -> Vec<CeltCoef> {
    assert!(overlap > 0, "overlap must be strictly positive");

    let mut window = Vec::with_capacity(overlap);
    let scale = core::f32::consts::FRAC_PI_2;
    let denom = overlap as f32;

    for i in 0..overlap {
        let phase = scale * ((i as f32 + 0.5) / denom);
        let sin_phase = sinf(phase);
        let value = sinf(scale * sin_phase * sin_phase);
        window.push(value);
    }

    window
}

/// Computes the log-band widths used by CELT's allocation heuristics.
///
/// Mirrors the loop inside `opus_custom_mode_create()` that populates the
/// `mode->logN` array by applying the `log2_frac()` helper to each energy band.
/// The results are expressed with [`BITRES`] fractional bits, matching the
/// conservative rounding performed by the C reference implementation.
#[must_use]
pub(crate) fn compute_log_band_widths(layout: &EBandLayout) -> Vec<OpusInt16> {
    use crate::celt::cwrs::log2_frac;
    use crate::celt::entcode::BITRES;
    use crate::celt::types::OpusInt16;

    assert!(layout.bands.len() >= layout.num_bands + 1);

    let mut log_n = Vec::with_capacity(layout.num_bands);
    for band in 0..layout.num_bands {
        let start = layout.bands[band];
        let end = layout.bands[band + 1];
        let width = i32::from(end - start);
        assert!(width > 0, "band width must be positive");
        let value = log2_frac(width as u32, BITRES as i32) as OpusInt16;
        log_n.push(value);
    }

    log_n
}

#[cfg(test)]
mod tests {
    use alloc::vec;
    use alloc::vec::Vec;

    use super::{
        BAND_ALLOCATION, BITALLOC_SIZE, EBAND_5MS, compute_allocation_table, compute_ebands,
        compute_log_band_widths, compute_mdct_window, compute_preemphasis,
    };
    use crate::celt::cwrs::log2_frac;

    #[test]
    fn returns_standard_layout_for_5ms_frames() {
        let layout = compute_ebands(48_000, 120, 200);
        assert_eq!(layout.num_bands, EBAND_5MS.len() - 1);
        assert_eq!(layout.bands, EBAND_5MS.to_vec());
    }

    #[test]
    fn computes_layout_for_48k_10ms_frame() {
        let frame_size = 480usize;
        let resolution = ((48_000 + frame_size as i32) / (2 * frame_size as i32)) as i32;
        let layout = compute_ebands(48_000, frame_size, resolution);
        let expected: Vec<i16> = vec![
            0, 2, 4, 6, 8, 10, 12, 15, 18, 22, 26, 30, 34, 40, 46, 54, 64, 74, 88, 106, 128, 154,
            190, 240, 310, 400,
        ];
        assert_eq!(layout.num_bands, expected.len() - 1);
        assert_eq!(layout.bands, expected);
    }

    #[test]
    fn computes_layout_for_16k_frame() {
        let frame_size = 320usize;
        let resolution = ((16_000 + frame_size as i32) / (2 * frame_size as i32)) as i32;
        let layout = compute_ebands(16_000, frame_size, resolution);
        let expected: Vec<i16> = vec![
            0, 4, 8, 12, 16, 20, 26, 32, 38, 44, 52, 60, 70, 80, 92, 108, 126, 148, 176, 212, 256,
            308,
        ];
        assert_eq!(layout.num_bands, expected.len() - 1);
        assert_eq!(layout.bands, expected);
    }

    #[test]
    fn allocation_table_matches_reference_for_standard_mode() {
        let layout = super::EBandLayout::new(EBAND_5MS.to_vec(), EBAND_5MS.len() - 1);
        let table = compute_allocation_table(48_000, 120, &layout);
        assert_eq!(table.num_vectors(), BITALLOC_SIZE);
        assert_eq!(table.num_bands(), layout.num_bands);
        let expected = &BAND_ALLOCATION[..BITALLOC_SIZE * layout.num_bands];
        assert_eq!(table.vectors(), expected);
    }

    #[test]
    fn allocation_table_interpolates_for_custom_mode() {
        let short_mdct_size = 240usize;
        let resolution = ((48_000 + short_mdct_size as i32) / (2 * short_mdct_size as i32)) as i32;
        let layout = compute_ebands(48_000, short_mdct_size, resolution);
        let table = compute_allocation_table(48_000, short_mdct_size, &layout);
        assert_eq!(table.num_vectors(), BITALLOC_SIZE);
        assert_eq!(table.num_bands(), layout.num_bands);
        let expected: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90, 85, 80,
            77, 75, 72, 69, 63, 56, 49, 40, 34, 31, 29, 20, 18, 10, 2, 0, 0, 0, 0, 0, 0, 0, 110,
            105, 100, 95, 90, 87, 84, 78, 71, 65, 58, 51, 48, 45, 39, 32, 26, 21, 16, 3, 0, 0, 0,
            0, 0, 118, 114, 110, 106, 103, 98, 93, 86, 80, 75, 70, 65, 62, 59, 53, 47, 40, 33, 27,
            17, 7, 0, 0, 0, 0, 126, 122, 119, 115, 112, 108, 104, 95, 89, 83, 78, 72, 69, 66, 60,
            54, 47, 41, 35, 26, 19, 12, 1, 0, 0, 134, 130, 127, 123, 120, 117, 114, 103, 97, 91,
            85, 78, 75, 72, 66, 60, 54, 48, 44, 36, 31, 24, 16, 10, 1, 144, 140, 137, 133, 130,
            127, 124, 113, 107, 101, 95, 88, 85, 82, 76, 70, 64, 58, 54, 46, 41, 34, 26, 15, 1,
            152, 148, 145, 141, 138, 135, 132, 123, 117, 111, 105, 98, 95, 92, 86, 80, 74, 68, 64,
            56, 51, 44, 36, 20, 1, 162, 158, 155, 151, 148, 145, 142, 133, 127, 121, 115, 108, 105,
            102, 96, 90, 84, 78, 74, 66, 61, 54, 46, 30, 1, 172, 168, 165, 161, 158, 155, 152, 143,
            137, 131, 125, 118, 115, 112, 106, 100, 94, 88, 84, 76, 71, 64, 56, 45, 20, 200, 200,
            200, 200, 200, 200, 200, 200, 200, 200, 200, 198, 195, 193, 188, 183, 178, 174, 170,
            164, 159, 153, 148, 129, 104,
        ];
        assert_eq!(table.vectors(), expected.as_slice());
    }

    #[test]
    fn compute_preemphasis_matches_reference_thresholds() {
        let low = compute_preemphasis(8_000);
        assert_eq!(low, [0.350_006_1, -0.179_992_68, 0.271_996_8, 3.676_513_7]);

        let mid = compute_preemphasis(16_000);
        assert_eq!(mid, [0.600_006_1, -0.179_992_68, 0.442_499_88, 2.259_887_7]);

        let high = compute_preemphasis(32_000);
        assert_eq!(high, [0.779_998_8, -0.100_006_1, 0.749_977_1, 1.333_374]);

        let full = compute_preemphasis(48_000);
        assert_eq!(full, [0.850_006_1, 0.0, 1.0, 1.0]);
    }

    #[test]
    fn compute_mdct_window_matches_reference_formula() {
        let overlap = 16usize;
        let window = compute_mdct_window(overlap);
        assert_eq!(window.len(), overlap);

        for (i, value) in window.iter().enumerate() {
            let phase = core::f64::consts::FRAC_PI_2 * ((i as f64 + 0.5) / overlap as f64);
            let sin_phase = phase.sin();
            let expected = (core::f64::consts::FRAC_PI_2 * sin_phase * sin_phase).sin();
            assert!(
                (f64::from(*value) - expected).abs() < 1e-6,
                "window[{}] mismatch: {} vs {}",
                i,
                value,
                expected
            );
        }
    }

    #[test]
    fn compute_log_band_widths_matches_log2_frac() {
        let layout = compute_ebands(48_000, 120, 200);
        let log_n = compute_log_band_widths(&layout);
        assert_eq!(log_n.len(), layout.num_bands);

        for (band, &value) in log_n.iter().enumerate() {
            let width = i32::from(layout.bands[band + 1] - layout.bands[band]);
            let expected = log2_frac(width as u32, 3) as i16;
            assert_eq!(value, expected, "band {} mismatch", band);
        }
    }
}
